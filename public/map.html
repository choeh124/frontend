<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map with Tmap API</title>
    <style>
      #map_div {
        width: 280px;
        height: 700px;
      }

      #result {
        font-size: 13px;
        text-align: center;
        font-weight: 400;
        color: #0094ff;
      }

      #address {
        width: 160px;
        padding: 5px 10px;
        border-radius: 5px;
        background-color: #42adfb;
        color: white !important;
        border: none;
      }

      #address::placeholder {
        color: white;
      }

      #drawLineBtn,
      #recordButton {
        padding: 5px;
        font-size: 10px;
        cursor: pointer;
        border: 1px solid #42adfb;
        /* ë²„íŠ¼ í…Œë‘ë¦¬ ìƒ‰ìƒ */
        border-radius: 4px;
        /* ë²„íŠ¼ ë‘¥ê¸€ê²Œ */
        background-color: #fff;
        /* ë²„íŠ¼ ë°°ê²½ìƒ‰ */
        color: #42adfb;
        /* ë²„íŠ¼ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
      }

      /* ë²„íŠ¼ í˜¸ë²„ íš¨ê³¼ */
      #drawLineBtn:hover,
      #recordButton:hover {
        background-color: #42adfb;
        /* ë²„íŠ¼ ë°°ê²½ ìƒ‰ìƒ ë³€ê²½ */
        color: white;
        /* ë²„íŠ¼ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½ */
      }

      #addr {
        padding: 3px 10px;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: center;
        font-size: 10px;
        color: gray;
        width: 260px;
        height: 20px;
        border: 1px solid #d2d2d2;
        border-radius: 20px;
      }

      #search-box {
        gap: 10px;
        padding: 10px;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
      }

      #route {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 5px;
      }
    </style>
    <script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey=BiGizFCY2P9VSwbZPJ4Mz1YuVwY7dEyH8dna6U4D"></script>
  </head>

  <body>
    <div id="map_div"></div>
    <div id="search-box">
      <input id="address" placeholder="ì¶œë°œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”." />
      <button id="recordButton">ğŸ™ï¸</button>
      <button id="drawLineBtn">ì „ì†¡</button>
    </div>

    <p id="result"></p>
    <div id="route"></div>

    <script>
      // Azure Key
      let gptKey = "";
      let sttKey = "";
      async function key() {
        const keyRespnose = await fetch(
          "https://shortwalk-f3byftbfe4czehcg.koreacentral-01.azurewebsites.net/api/key"
        );
        const keyResult = await keyRespnose.json();
        gptKey = keyResult.gptKey;
        sttKey = keyResult.sttKey;
      }

      key();
      // STT ë¡œì§
      let isRecording = false;
      let mediaRecorder;
      let audioChunks = [];

      const recordButton = document.getElementById("recordButton");
      const speechTextElement = document.getElementById("address");

      async function startRecording() {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        mediaRecorder = new MediaRecorder(stream);

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          const arrayBuffer = await audioBlob.arrayBuffer();
          const audioBuffer = await new AudioContext().decodeAudioData(
            arrayBuffer
          );

          const wavBlob = encodeWAV(
            audioBuffer.getChannelData(0),
            audioBuffer.sampleRate
          );
          const wavUrl = URL.createObjectURL(wavBlob);

          handleSpeechToText(wavBlob);

          audioChunks = [];
        };

        mediaRecorder.start();
        isRecording = true;
        recordButton.textContent = "âœ”ï¸";
      }

      function stopRecording() {
        mediaRecorder.stop();
        isRecording = false;
        recordButton.textContent = "ğŸ™ï¸";
      }

      recordButton.addEventListener("click", () => {
        if (isRecording) {
          console.log(sttKey);
          stopRecording();
        } else {
          startRecording();
        }
      });

      async function handleSpeechToText(audioBlob) {
        try {
          const response = await sendAudioToServer(audioBlob); // Replace with actual API request
          speechTextElement.value = response; // Display converted text
        } catch (error) {
          console.error("Error occurred:", error);
        }
      }

      const sendAudioToServer = async (audioBlob) => {
        const endPoint =
          "https://koreacentral.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=ko-KR";

        const response = await fetch(endPoint, {
          method: "POST",
          headers: {
            "Ocp-Apim-Subscription-Key": sttKey,
            "Content-Type": "audio/wav",
          },
          body: audioBlob,
        });
        const data = await response.json();
        return data.DisplayText;
      };

      function encodeWAV(channelData, sampleRate) {
        const buffer = new ArrayBuffer(44 + channelData.length * 2);
        const view = new DataView(buffer);

        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + channelData.length * 2, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");

        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);

        writeString(view, 36, "data");
        view.setUint32(40, channelData.length * 2, true);

        let offset = 44;
        for (let i = 0; i < channelData.length; i++) {
          view.setInt16(offset, channelData[i] * 32767, true);
          offset += 2;
        }

        return new Blob([view], { type: "audio/wav" });
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      // ì§€ë„ ë¡œì§
      let address;
      const { Tmapv2 } = window;
      const headers = { appKey: "BiGizFCY2P9VSwbZPJ4Mz1YuVwY7dEyH8dna6U4D" };
      let map;
      let marker_s, marker_e;
      let drawInfoArr = [];
      let resultdrawArr = [];
      let intermediatePoints = [];
      let geocoder;
      let addresses = [];

      // GPT API í˜¸ì¶œ ë° ì£¼ì†Œ ë¶„ì„
      async function gpt(address) {
        initTmap();
        drawInfoArr = [];
        resultdrawArr = [];
        intermediatePoints = [];
        addresses = [];
        const promptData = {
          messages: [
            {
              role: "system",
              content:
                "ë„ˆëŠ” ì£¼ì–´ì§„ ë¬¸ì¥ì„ í•´ì„í•´ì„œ ë„ë¡œëª…ì£¼ì†Œë§Œì„ ë°°ì—´ì— ë‹´ì•„ jsonìœ¼ë¡œ ê°ì‹¸ ì¶œë ¥í•˜ëŠ” AIì•¼. ì‚°ì±… ê²½ë¡œëŠ” ë¬´ì¡°ê±´ 3km ë‚´ì™¸ë¡œ ì¶”ì²œí•´ ì¤˜ì•¼ í•´.",
            },
            {
              role: "user",
              content: `${address}ì—ì„œ ì¶œë°œí•˜ê³  ëë‚˜ëŠ” ì´ 3kmì˜ ì™•ë³µ ì‚°ì±… ì½”ìŠ¤ì˜ ì¶œë°œì§€ 1ê°œì˜ ë„ë¡œëª…ì£¼ì†Œì™€ ì¤‘ê°„ì§€ì  5ê°œ ë„ë¡œëª…ì£¼ì†Œë¥¼ ë°°ì—´ì— ë‹´ì•„ì„œ dataë¼ëŠ” keyë¥¼ ê°€ì§„ jsonì— ë„£ì–´ ì¤˜.`,
            },
          ],
        };

        const gptResponse = await fetch(
          "https://warme-m3p2wioi-francecentral.cognitiveservices.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-08-01-preview",
          {
            method: "POST",
            headers: { "api-key": gptKey, "Content-Type": "application/json" },
            body: JSON.stringify(promptData),
          }
        );

        if (gptResponse.status === 429) {
          window.location.reload();
          alert(
            "AIê°€ ê³¼ë¡œí•˜ì—¬ íœ´ì‹ì´ í•„ìš”í•©ë‹ˆë‹¤. ì ì‹œ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
          );
          return;
        }
        const gptResult = await gptResponse.json();
        const cleanedResult = gptResult.choices[0].message.content
          .replace(/^```json\n/, "")
          .replace(/\n```$/, "")
          .trim();
        const result = await JSON.parse(cleanedResult);

        // geocoding ì²˜ë¦¬ í›„ ê²½ë¡œ ê·¸ë¦¬ê¸°
        await Promise.all(
          result.data.map((addressStr) => {
            return new Promise((resolve) => {
              setTimeout(async () => {
                const result = await geocoding(addressStr);

                if (result) {
                  resolve(); // geocoding ì™„ë£Œ í›„ resolve
                }
              }, 300);
            });
          })
        ).finally(() => {
          // ëª¨ë“  geocodingì´ ì™„ë£Œëœ í›„ ê²½ë¡œ ìš”ì²­
          fetchRouteData();
        });
      }

      // ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
      async function geocoding(address) {
        try {
          addresses.push(address);
          const response = await fetch(
            `https://apis.openapi.sk.com/tmap/geo/fullAddrGeo?addressFlag=F02&coordType=WGS84GEO&version=1&fullAddr=${address}&page=1&count=1`,
            {
              method: "GET",
              headers,
            }
          );
          const result = await response.json();
          const data = {
            x: result.coordinateInfo.coordinate[0].newLat,
            y: result.coordinateInfo.coordinate[0].newLon,
          };
          intermediatePoints.push(new Tmapv2.LatLng(data.x, data.y));
          return true;
        } catch (err) {
          initTmap();
          drawInfoArr = [];
          resultdrawArr = [];
          intermediatePoints = [];
          addresses = [];
          setTimeout(async () => {
            gpt(address);
          }, 300);
        }
      }

      // Tmap ì§€ë„ ì´ˆê¸°í™”
      function initTmap() {
        const mapDiv = document.getElementById("map_div");

        if (!mapDiv.firstChild) {
          map = new Tmapv2.Map("map_div", {
            center: new Tmapv2.LatLng(37.566481622437934, 126.98502302169841),
            width: "280px",
            height: "280px",
            zoom: 14,
          });
        }
      }

      // ê²½ë¡œ ìš”ì²­ ë° ì§€ë„ì— ê·¸ë¦¬ê¸°
      async function fetchRouteData() {
        if (intermediatePoints.length < 2) {
          alert("ê²½ë¡œë¥¼ ê·¸ë¦´ ìˆ˜ ìˆëŠ” ì¶©ë¶„í•œ ì ì´ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        const startPoint = intermediatePoints[0]; // ì¶œë°œì§€
        const endPoint = intermediatePoints[intermediatePoints.length - 1]; // ë„ì°©ì§€

        const requestData = {
          startX: startPoint.lng(),
          startY: startPoint.lat(),
          endX: endPoint.lng(),
          endY: endPoint.lat(),
          reqCoordType: "WGS84GEO",
          resCoordType: "EPSG3857",
          startName: "ì¶œë°œì§€",
          endName: "ë„ì°©ì§€",
        };

        try {
          const response = await fetch(
            "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json&callback=result",
            {
              method: "POST",
              headers: headers,
              body: JSON.stringify(requestData),
            }
          );

          const data = await response.json();

          if (response.ok) {
            processRouteData(data);
          } else {
            throw new Error("Failed to fetch route data");
          }
        } catch (error) {
          initTmap();
          drawInfoArr = [];
          resultdrawArr = [];
          intermediatePoints = [];
          addresses = [];
          setTimeout(async () => {
            gpt(address);
          }, 300);
        }
      }

      // ê²½ë¡œ ë°ì´í„° ì²˜ë¦¬ ë° ì§€ë„ì— ê²½ë¡œ ê·¸ë¦¬ê¸°
      function processRouteData(responseData) {
        const resultData = responseData.features;

        // ê¸°ì¡´ ë§ˆì»¤ ë° ì„  ì œê±°
        resultdrawArr.forEach((marker) => marker.setMap(null));
        resultdrawArr = [];
        drawInfoArr = [];

        resultData.forEach((feature) => {
          const { geometry, properties } = feature;
          if (geometry.type === "LineString") {
            geometry.coordinates.forEach((coordinate) => {
              const latlng = new Tmapv2.Point(coordinate[0], coordinate[1]);
              const convertPoint =
                new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);
              const convertChange = new Tmapv2.LatLng(
                convertPoint._lat,
                convertPoint._lng
              );
              drawInfoArr.push(convertChange);
            });
          }
        });

        drawLine(drawInfoArr); // ì§€ë„ì— ê²½ë¡œ ì„  ê·¸ë¦¬ê¸°
        moveMapCenterToMiddle(drawInfoArr); // ê²½ë¡œ ì¤‘ì‹¬ìœ¼ë¡œ ì§€ë„ ì´ë™
        addIntermediateMarkers(intermediatePoints); // ì¤‘ê°„ ì§€ì  ë§ˆì»¤ ì¶”ê°€

        const tDistance = `ì´ ê±°ë¦¬ : ${(
          resultData[0].properties.totalDistance / 1000
        ).toFixed(1)}km,`;
        const tTime = ` ì´ ì‹œê°„ : ${(
          resultData[0].properties.totalTime / 60
        ).toFixed(0)}ë¶„`;
        document.querySelector("#result").innerHTML = tDistance + tTime;
        addresses.push(addresses[0]);
        const tempHTML = addresses
          .map((addr) => {
            return `<div id = "addr">${addr}</div>`;
          })
          .join("");
        document.querySelector("#route").innerHTML = tempHTML;
      }

      // ì§€ë„ì— ê²½ë¡œ ì„  ê·¸ë¦¬ê¸°
      function drawLine(arrPoint) {
        const polyline = new Tmapv2.Polyline({
          path: arrPoint,
          strokeColor: "#DD0000",
          strokeWeight: 6,
          map: map,
        });
        resultdrawArr.push(polyline);
      }

      // ê²½ë¡œ ì¤‘ê°„ ì§€ì  ë§ˆì»¤ ì¶”ê°€
      function addIntermediateMarkers(points) {
        points.forEach((point) => {
          const marker = new Tmapv2.Marker({
            position: point,
            icon: "http://topopen.tmap.co.kr/imgs/point.png",
            iconSize: new Tmapv2.Size(8, 8),
            map: map,
          });
          resultdrawArr.push(marker);
        });
      }

      // ê²½ë¡œ ì¤‘ì‹¬ìœ¼ë¡œ ì§€ë„ ì´ë™
      function moveMapCenterToMiddle(arrPoint) {
        let lat = 0;
        let lng = 0;
        arrPoint.forEach((point) => {
          lat += point.lat();
          lng += point.lng();
        });
        lat /= arrPoint.length;
        lng /= arrPoint.length;
        map.setCenter(new Tmapv2.LatLng(lat, lng));
      }

      // "ê²½ë¡œ ê·¸ë¦¬ê¸°" ë²„íŠ¼ í´ë¦­ ì‹œ ì²˜ë¦¬
      document.getElementById("drawLineBtn").addEventListener("click", () => {
        document.querySelector("#result").innerHTML =
          "ì¶”ì²œ ê²½ë¡œë¥¼ íƒìƒ‰í•˜ê³  ìˆìŠµë‹ˆë‹¤.";
        address = document.getElementById("address").value;
        if (address) {
          gpt(address);
        } else {
          alert("ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
        }
      });

      // Enter í‚¤ë¥¼ ëˆŒë €ì„ ë•Œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
      document
        .getElementById("address")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            document.getElementById("drawLineBtn").click(); // Enter í‚¤ê°€ ëˆŒë¦¬ë©´ ë²„íŠ¼ í´ë¦­
          }
        });

      // ì§€ë„ ì´ˆê¸°í™”
      initTmap();
    </script>
  </body>
</html>
